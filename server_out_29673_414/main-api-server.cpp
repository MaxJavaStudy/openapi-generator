/**
 * Nucmf_UECapabilityManagement
 * Nucmf_UECapabilityManagement Service. Â© 2021, 3GPP Organizational Partners
 * (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.0.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "jsonParser.hpp"
#include <nghttp2/asio_http2_server.h>
#include <nghttp2/http_router.hpp>
#include <signal.h>
#include <unistd.h>
#include <vector>

#include "ADictionaryEntryDocumentApi.h"
#include "DicEntryIdDocumentApi.h"
#include "DictionaryEntryStoreApi.h"
#include "IndividualSubscriptionDocumentApi.h"
#include "SubscriptionsCollectionApi.h"

#include "AccessTokenErr.h"

#include "AccessTokenReq.h"

#include "CreateSubscription.h"

#include "CreatedSubscription.h"

#include "DicEntryCreateData.h"

#include "DicEntryCreatedData.h"

#include "DicEntryData.h"

#include "EventType.h"

#include "Inline_object.h"

#include "Inline_response_200.h"

#include "InvalidParam.h"

#include "ManAssOpRequestlist.h"

#include "NFType.h"

#include "PlmnId.h"

#include "PlmnIdNid.h"

#include "ProblemDetails.h"

#include "RacFormat.h"

#include "RefToBinaryData.h"

#include "Snssai.h"

#include "UcmfNotification.h"

#include "UeRadioCapaId.h"

#include <nghttp2/asio_http2_server.h>
static void sigHandler [[noreturn]] (int sig) {
  switch (sig) {
  case SIGINT:
  case SIGQUIT:
  case SIGTERM:
  case SIGHUP:
  default:
    // to do
    // what should we do when signal happens?
    break;
  }
  exit(0);
}

static void setUpUnixSignals(std::vector<int> quitSignals) {
  sigset_t blocking_mask;
  sigemptyset(&blocking_mask);
  for (auto sig : quitSignals)
    sigaddset(&blocking_mask, sig);

  struct sigaction sa;
  sa.sa_handler = sigHandler;
  sa.sa_mask = blocking_mask;
  sa.sa_flags = 0;

  for (auto sig : quitSignals)
    sigaction(sig, &sa, nullptr);
}

using namespace org::openapitools::server::api;

int main(int argc, char *argv[]) {

  std::vector<int> sigs{SIGQUIT, SIGINT, SIGTERM, SIGHUP};
  setUpUnixSignals(sigs);

  // server
  try {
    // Check command line arguments.
    if (argc < 4) {
      std::cerr
          << "Usage: asio-sv <address> <port> <threads> [<private-key-file> "
          << "<cert-file>]\n";
      return 1;
    }

    boost::system::error_code ec;

    std::string addr = argv[1];
    std::string port = argv[2];
    std::size_t num_threads = std::stoi(argv[3]);

    std::cout << "start server with addr :" << addr << ", port : " << port
              << ", thread mumber :" << num_threads << std::endl;

    http2 server;

    server.num_threads(num_threads);

    // load API schema
    static std::string apiSchemaBasePath = "";

    jsonParser::jsonParser<AccessTokenErr>::loadApiSchema(
        apiSchemaBasePath + "AccessTokenErr.json");

    jsonParser::jsonParser<AccessTokenReq>::loadApiSchema(
        apiSchemaBasePath + "AccessTokenReq.json");

    jsonParser::jsonParser<CreateSubscription>::loadApiSchema(
        apiSchemaBasePath + "CreateSubscription.json");

    jsonParser::jsonParser<CreatedSubscription>::loadApiSchema(
        apiSchemaBasePath + "CreatedSubscription.json");

    jsonParser::jsonParser<DicEntryCreateData>::loadApiSchema(
        apiSchemaBasePath + "DicEntryCreateData.json");

    jsonParser::jsonParser<DicEntryCreatedData>::loadApiSchema(
        apiSchemaBasePath + "DicEntryCreatedData.json");

    jsonParser::jsonParser<DicEntryData>::loadApiSchema(apiSchemaBasePath +
                                                        "DicEntryData.json");

    jsonParser::jsonParser<EventType>::loadApiSchema(apiSchemaBasePath +
                                                     "EventType.json");

    jsonParser::jsonParser<Inline_object>::loadApiSchema(apiSchemaBasePath +
                                                         "Inline_object.json");

    jsonParser::jsonParser<Inline_response_200>::loadApiSchema(
        apiSchemaBasePath + "Inline_response_200.json");

    jsonParser::jsonParser<InvalidParam>::loadApiSchema(apiSchemaBasePath +
                                                        "InvalidParam.json");

    jsonParser::jsonParser<ManAssOpRequestlist>::loadApiSchema(
        apiSchemaBasePath + "ManAssOpRequestlist.json");

    jsonParser::jsonParser<NFType>::loadApiSchema(apiSchemaBasePath +
                                                  "NFType.json");

    jsonParser::jsonParser<PlmnId>::loadApiSchema(apiSchemaBasePath +
                                                  "PlmnId.json");

    jsonParser::jsonParser<PlmnIdNid>::loadApiSchema(apiSchemaBasePath +
                                                     "PlmnIdNid.json");

    jsonParser::jsonParser<ProblemDetails>::loadApiSchema(
        apiSchemaBasePath + "ProblemDetails.json");

    jsonParser::jsonParser<RacFormat>::loadApiSchema(apiSchemaBasePath +
                                                     "RacFormat.json");

    jsonParser::jsonParser<RefToBinaryData>::loadApiSchema(
        apiSchemaBasePath + "RefToBinaryData.json");

    jsonParser::jsonParser<Snssai>::loadApiSchema(apiSchemaBasePath +
                                                  "Snssai.json");

    jsonParser::jsonParser<UcmfNotification>::loadApiSchema(
        apiSchemaBasePath + "UcmfNotification.json");

    jsonParser::jsonParser<UeRadioCapaId>::loadApiSchema(apiSchemaBasePath +
                                                         "UeRadioCapaId.json");

    // register server handler

    server.register_handler<POST>(
        "/dic-entries",
        &ADictionaryEntryDocumentApi::create_dictionary_entry_handler);

    server.register_handler<GET>("/dic-entries/:dicEntryId",
                                 &DicEntryIdDocumentApi::get_dic_entry_handler);

    server.register_handler<GET>(
        "/dic-entries",
        &DictionaryEntryStoreApi::retrieve_dictionary_entry_handler);

    server.register_handler<DELETE>("/subscriptions/:subscriptionId",
                                    &IndividualSubscriptionDocumentApi::
                                        delete_individual_subcription_handler);

    server.register_handler<POST>(
        "/subscriptions",
        &SubscriptionsCollectionApi::create_individual_subcription_handler);

    // ssl? server start
    if (argc >= 6) {
      boost::asio::ssl::context tls(boost::asio::ssl::context::sslv23);
      tls.use_private_key_file(argv[4], boost::asio::ssl::context::pem);
      tls.use_certificate_chain_file(argv[5]);

      configure_tls_context_easy(ec, tls);

      if (server.listen_and_serve(ec, tls, addr, port)) {
        std::cerr << "error: " << ec.message() << std::endl;
      }
    } else {
      if (server.listen_and_serve(ec, addr, port)) {
        std::cerr << "error: " << ec.message() << std::endl;
      }
    }
  } catch (std::exception &e) {
    std::cerr << "exception: " << e.what() << "\n";
  }

  return 0;
}
