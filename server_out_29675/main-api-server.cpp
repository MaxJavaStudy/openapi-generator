/**
 * Nucmf_Provisioning
 * UCMF_Provisioning Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0-alpha.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "jsonParser.h"
#include <signal.h>
#include <unistd.h>
#include <vector>

#include "IndividualUERadioCapabilityProvisioningDocumentApi.h"
#include "UERadioCapabilityProvisioningsCollectionApi.h"

static void sigHandler [[noreturn]] (int sig) {
  switch (sig) {
  case SIGINT:
  case SIGQUIT:
  case SIGTERM:
  case SIGHUP:
  default:
    // to do
    // what should we do when signal happens?
    break;
  }
  exit(0);
}

static void setUpUnixSignals(std::vector<int> quitSignals) {
  sigset_t blocking_mask;
  sigemptyset(&blocking_mask);
  for (auto sig : quitSignals)
    sigaddset(&blocking_mask, sig);

  struct sigaction sa;
  sa.sa_handler = sigHandler;
  sa.sa_mask = blocking_mask;
  sa.sa_flags = 0;

  for (auto sig : quitSignals)
    sigaction(sig, &sa, nullptr);
}

using namespace org::openapitools::server::api;

int main(int argc, char *argv[]) {

  std::vector<int> sigs{SIGQUIT, SIGINT, SIGTERM, SIGHUP};
  setUpUnixSignals(sigs);

  // server
  try {
    // Check command line arguments.
    if (argc < 4) {
      std::cerr
          << "Usage: asio-sv <address> <port> <threads> [<private-key-file> "
          << "<cert-file>]\n";
      return 1;
    }

    boost::system::error_code ec;

    std::string addr = argv[1];
    std::string port = argv[2];
    std::size_t num_threads = std::stoi(argv[3]);

    std::cout << "start server with addr :" << addr << ", port : " << port
              << ", thread mumber :" << num_threads << std::endl;

    http2 server;

    server.num_threads(num_threads);

    // load API schema
    static std::string apiSchemaBasePath = "";

    jsonParser::jsonParser<InvalidParam>::loadApiSchema(apiSchemaBasePath +
                                                        "InvalidParam");

    jsonParser::jsonParser<ProblemDetails>::loadApiSchema(apiSchemaBasePath +
                                                          "ProblemDetails");

    jsonParser::jsonParser<RacsConfiguration>::loadApiSchema(
        apiSchemaBasePath + "RacsConfiguration");

    jsonParser::jsonParser<RacsConfigurationRm>::loadApiSchema(
        apiSchemaBasePath + "RacsConfigurationRm");

    jsonParser::jsonParser<RacsData>::loadApiSchema(apiSchemaBasePath +
                                                    "RacsData");

    jsonParser::jsonParser<RacsDataPatch>::loadApiSchema(apiSchemaBasePath +
                                                         "RacsDataPatch");

    jsonParser::jsonParser<RacsFailureCode>::loadApiSchema(apiSchemaBasePath +
                                                           "RacsFailureCode");

    jsonParser::jsonParser<RacsFailureReport>::loadApiSchema(
        apiSchemaBasePath + "RacsFailureReport");

    // register server handler

    server.register_handler<GET>(
        "/provisionings/:provisioningId",
        &IndividualUERadioCapabilityProvisioningDocumentApi::
            get_provisioning_handler);

    server.register_handler<DELETE>(
        "/provisionings/:provisioningId",
        &IndividualUERadioCapabilityProvisioningDocumentApi::
            remove_provisioning_handler);

    server.register_handler<PUT>(
        "/provisionings/:provisioningId",
        &IndividualUERadioCapabilityProvisioningDocumentApi::
            replace_provisioning_handler);

    server.register_handler<PATCH>(
        "/provisionings/:provisioningId",
        &IndividualUERadioCapabilityProvisioningDocumentApi::
            update_provisioning_handler);

    server.register_handler<POST>("/provisionings",
                                  &UERadioCapabilityProvisioningsCollectionApi::
                                      create_provisioning_handler);

    // ssl? server start
    if (argc >= 6) {
      boost::asio::ssl::context tls(boost::asio::ssl::context::sslv23);
      tls.use_private_key_file(argv[4], boost::asio::ssl::context::pem);
      tls.use_certificate_chain_file(argv[5]);

      configure_tls_context_easy(ec, tls);

      if (server.listen_and_serve(ec, tls, addr, port)) {
        std::cerr << "error: " << ec.message() << std::endl;
      }
    } else {
      if (server.listen_and_serve(ec, addr, port)) {
        std::cerr << "error: " << ec.message() << std::endl;
      }
    }
  } catch (std::exception &e) {
    std::cerr << "exception: " << e.what() << "\n";
  }

  return 0;
}
